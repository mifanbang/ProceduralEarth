class ShaderArchive {
	static readonly atmoscattering_fs_part: string = '// dependencies:\n//   - cloud_tl.glsl\n//   - scattering_tl.glsl\nuniform vec3	u_lightColor;\nuniform vec3	u_viewPos;\nuniform float	u_radiusAtmo;\nuniform mat4	u_invModelMat;\nvarying vec3	v_worldPosition;	// world-space position (normalized)\nvarying vec3	v_worldNormal;		// world-space normal (normalized)\nvoid main(void) {\n	// invariants\n	vec3 worldNormal = normalize(v_worldNormal);\n	vec3 viewDir = normalize(v_worldPosition - u_viewPos);\n	float atmoRadius = u_planetRadius + u_atmoThickness;  // unit: m\n	float glUnitToMeter = atmoRadius / u_radiusAtmo;\n	// intersection\n	InScatteringParam inSctrParam;\n	inSctrParam.viewPos = u_viewPos * glUnitToMeter;\n	inSctrParam.viewDir = viewDir;\n	inSctrParam.lightDir = u_lightDir;\n	PlanetIntersectResult intsct = IntersectPlanet(inSctrParam);\n	// hit test with clouds\n	if (intsct.hitsGround) {\n		vec3 posWorldSpace = v_worldPosition * glUnitToMeter;  // unit: m\n		vec3 cloudSampleWorldSpace = GetCloudSamplePosition(posWorldSpace, viewDir, u_planetRadius);\n		vec3 cloudSampleModelSpace = (u_invModelMat * vec4(normalize(cloudSampleWorldSpace), 0.0)).xyz;\n		float cloudThickness = EvalCloudThickness(SampleCloud(cloudSampleModelSpace));\n		if (cloudThickness > 0.0) {\n			// use blending on $distToFarInter to avoid sudden change of in-scattering\n			const float INV_BLENDING_HEIGHT = 1.0 / 5e2;  // 500 meters\n			float newDistToFarInter = intsct.t.distToNearInter + distance(cloudSampleWorldSpace, posWorldSpace) - cloudThickness;\n			intsct.t.distToFarInter = mix(intsct.t.distToFarInter, newDistToFarInter, min(cloudThickness * INV_BLENDING_HEIGHT, 1.0));\n		}\n	}\n	gl_FragColor.xyz = IntegrateInScattering(inSctrParam, intsct) * u_lightColor;\n	gl_FragColor.w = 1.0;\n}\n';
	static readonly atmotransmittance_fs_part: string = '// dependencies:\n//   - scattering_tl.glsl\nuniform vec3	u_lightDir;\nuniform vec3	u_viewPos;\nuniform float	u_radiusAtmo;\nvarying vec3	v_worldPosition;	// world-space position (normalized)\nvoid main(void) {\n	vec3 viewDir = normalize(v_worldPosition - u_viewPos);\n	InScatteringParam inSctrParam;\n	inSctrParam.viewPos = u_viewPos * (u_planetRadius + u_atmoThickness) / u_radiusAtmo;\n	inSctrParam.viewDir = viewDir;\n	inSctrParam.lightDir = u_lightDir;\n	gl_FragColor.xyz = GetPlanetaryTransmittance(inSctrParam);\n	gl_FragColor.w = 1.0;\n}\n';
	static readonly background_vs: string = 'varying vec3	v_modelPosition;\nvoid main(void) {\n	gl_Position = vec4(position.xy, 1.0, 1.0);  // maximum of visible depth value (z=1)\n	v_modelPosition = gl_Position.xyz;\n}\n';
	static readonly brdf_tl: string = 'uniform vec3	u_viewPos;\nvarying vec3	v_worldPosition;	// world-space position (normalized)\nstruct SurfaceParam {\n	vec3	surfacePos;\n	float	dotSunLight;\n	float	fbm;\n	float	fbmAlt;\n};\nstruct SurfaceProperties {\n	vec3	albedo;\n	float	glossiness;\n	vec3	specularColor;\n	vec3	normal;\n	float	height;\n};\n// forward declarations\nSurfaceProperties CalcSurfaceProperties(SurfaceParam param);\n// TODO: normalization of BRDF\nvec3 CalcLommelSeeliger(vec3 albedo, vec3 normal, vec3 light, vec3 view) {\n	float uIncident = max(dot(light, normal), 0.0);\n	float uReflective = max(dot(view, normal), 0.0);\n	return albedo * uIncident / max(uIncident + uReflective, 1e-9);  // use max() to avoid the case of 0/0\n}\nvec3 CalcBRDF_Lambert(vec3 albedo, vec3 normal, vec3 light) {\n	const float invPI = 1.0 / 3.1415926;\n	return albedo * max(dot(normal, light), 0.0) * invPI;\n}\nvec3 CalcFresnel_Schlick(vec3 specularColor, float dotLH) {\n	vec3 blendingOpponent = vec3(pow(1.0 - max(dotLH, 0.0), 5.0));\n	return (1.0 - specularColor) * blendingOpponent + specularColor;\n}\nfloat CalcDistribution_Blinn(float sharpness, float dotNH) {\n	const float twoPI = 2.0 * 3.1415926;\n	return (sharpness + 2.0) / twoPI * pow(max(dotNH, 0.0), sharpness);\n}\nfloat CalcGeometry_CookTorrance(float dotNH_2_over_dotVH, float dotNV, float dotNL) {\n	float g1 = dotNH_2_over_dotVH * dotNV;\n	float g2 = dotNH_2_over_dotVH * dotNL;\n	return min(1.0, min(g1, g2));\n}\nfloat CalcBRDF_TorranceSparrow(vec3 N, vec3 L, vec3 V, float glossiness, vec3 specColor, out vec3 fresnel) {\n	vec3 H = normalize(V + L);\n	float specularPower = exp2(10.0 * glossiness + 1.0);\n	float dotNL = dot(N, L);\n	float dotNV = dot(N, V);\n	float dotNH = dot(N, H);\n	float dotVH = dot(V, H);\n	fresnel = CalcFresnel_Schlick(specColor, dotVH);  // dotLH = dotVH\n	float outRadianceScaler = \n		  CalcGeometry_CookTorrance(2.0 * dotNH / dotVH, dotNV, dotNL)\n		* CalcDistribution_Blinn(specularPower, dotNH)\n		/ (dotNV * 4.0);  // dotNL in the denominator is cancelled out because BRDF takes irradiance\n	return max(outRadianceScaler, 0.0);\n}\nvec3 CalcLighting(SurfaceProperties surface, vec3 lightDir) {\n	vec3 viewDir = normalize(u_viewPos - v_worldPosition);\n	// diffuse term: Lambert model\n	vec3 diffuse = CalcBRDF_Lambert(\n		max(surface.albedo, vec3(0.0)),\n		surface.normal,	// N\n		-lightDir	// L\n	);\n	// specular term: Torrance-Sparrow model\n	if (surface.glossiness > 0.0) {  // only render highlights if glossiness is explicitly assigned in DrawSurfaceColor()\n		vec3 fresnel;\n		float specular = CalcBRDF_TorranceSparrow(\n			surface.normal,	// N\n			-lightDir,	// L\n			viewDir,		// V\n			surface.glossiness,\n			surface.specularColor,\n			fresnel  // output: fresnel term\n		);\n		// TODO: aim is energy conservation. some say this formula is wrong at the diffisive part but it looks ok for now\n		return mix(diffuse, vec3(specular), fresnel);\n	}\n	else\n		return diffuse;\n}\n';
	static readonly cloud_fs_part: string = '// dependencies:\n//   - brdf_tl.glsl\n//   - cloud_tl.glsl\n//   - normal_tl.glsl\n//   - scattering_tl.glsl\nuniform vec3	u_lightColor;\nvarying vec3	v_modelPosition;	// model-space position\nvarying vec3	v_worldNormal;		// world-space normal (normalized)\nfloat EvalHenyeyGreenstein(float g, float cosTheta) {\n	const float INV_4_PI = 0.25 / 3.1415926;\n	float gSq = g * g;\n	return INV_4_PI * (1.0 - gSq) / pow(1.0 + gSq - 2.0 * g * cosTheta, 1.5);\n}\n// REF: Sebastien Hillaire. \"Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite\". SIGGRAPH 2016 Physically Based Shading in Theory and Practice course.\nfloat EvalPhase(float cosTheta) {\n	const float G_1 = 0.5;\n	const float G_2 = -0.3;\n	const float mixFactor = 0.7;  // weight for the G_1 term\n	return mix(EvalHenyeyGreenstein(G_2, cosTheta), EvalHenyeyGreenstein(G_1, cosTheta), mixFactor);\n}\nfloat EvalScattering(float phase, float opticalDepth) {\n	float opticalDepthAdj = min(opticalDepth, 0.549);  // f(x)=exp(-x)*(1-exp(-2x)) has global max at x=0.549\n	float transmittance = exp(-opticalDepthAdj);\n	float powderEffect = 1.0 - exp(-2.0 * opticalDepthAdj);\n	return phase * 2.0 * transmittance * powderEffect * opticalDepth;\n}\n// Lambertian diffuse lighting with \"baked-in\" ambient term\nfloat EvalCloudLighting(float thickness, float dotNL) {\n	const float ALBEDO = 0.8;\n	return max(dotNL, 0.1) * ALBEDO / 3.1415926;  // set mininum to dotNL to acoount for ambient from sky\n}\nvec3 FixViewerTransmittance(float dotNV, float height) {\n	return SampleTransmittance(dotNV, height) / SampleTransmittance(dotNV, 0.0);\n}\nvoid main(void) {\n	// invariants\n	vec3 modelNPos = normalize(v_modelPosition);  // normalized model-space position\n	vec3 worldNormal = normalize(v_worldNormal);\n	vec3 viewDir = normalize(v_worldPosition - u_viewPos);\n	float dotNL = -dot(worldNormal, u_lightDir);\n	float dotVL = dot(viewDir, u_lightDir);\n	float dotNV = -dot(worldNormal, viewDir);\n	// prepare properties\n	float noiseCloud = SampleCloud(modelNPos);\n	if (noiseCloud <= 0.0)\n		discard;\n	vec3 bumpNormal = CalcBumpNormal(modelNPos, noiseCloud, 3.33e-3);\n	float thickness = EvalCloudThickness(noiseCloud);\n	float opticalDepth = EvalCloudOpticalDepth(thickness);\n	// diffuse and scattering terms\n	float phase = EvalPhase(dotVL);\n	float scattering = EvalScattering(phase, opticalDepth);\n	float diffuse = EvalCloudLighting(thickness, max(-dot(bumpNormal, u_lightDir), 0.0));\n	// put all things together\n	vec3 incidentLight = u_lightColor * SampleTransmittance(dotNL, u_cloudHeight + thickness);\n	vec3 fixedTransmittance = FixViewerTransmittance(dotNV, u_cloudHeight + thickness);\n	vec3 radiance = incidentLight * mix(scattering, diffuse, 0.6) * fixedTransmittance;\n	float transmittance = EvalCloudTransmittance(opticalDepth);\n	gl_FragColor = vec4(radiance, 1.0 - transmittance);\n}\n';
	static readonly cloud_tl: string = '// dependencies:\n//   - color_tl.glsl\nuniform samplerCube	t_animNoise;\nuniform float	u_texBlendTime;\nuniform float	u_cloudAmount;\nuniform float	u_cloudHeight;\nuniform vec3	u_lightDir;\nfloat SampleCloud(vec3 position) {\n	vec4 packedAnimFBM = textureCube(t_animNoise, position);\n	float noiseCloud = u_cloudAmount + mix(\n		UnpackFromRGB_888(packedAnimFBM.rg),\n		UnpackFromRGB_888(packedAnimFBM.ba),\n		u_texBlendTime\n	);\n	return max(noiseCloud, 0.0);\n}\nfloat EvalCloudThickness(float noiseCloud) {\n	const float MAX_THICKNESS = 5e3;  // unit: m\n	return noiseCloud * MAX_THICKNESS;\n}\nfloat EvalCloudOpticalDepth(float thickness) {\n	const float EXTINCTION = 3.2e-4;  // REF: Egor Yusov. \"Real-Time Rendering of Physically Based Clouds Using Precomputed Scattering\". In GPU Pro 6, CRC Press, 2016.\n	return thickness * EXTINCTION;\n}\nfloat EvalCloudTransmittance(float opticalDepth) {\n	return pow(exp(-2.0 * opticalDepth), 10.0);\n}\n// $shadingPt can be either position on the ground or at the top of atmosphere\n// $inDir can be either light or view direction towards the shading point\nvec3 GetCloudSamplePosition(vec3 shadingPt, vec3 inDir, float planetRadius) {\n	float radiusCloud = planetRadius + u_cloudHeight;  // unit: m\n	vec3 lowestPos = inDir * -dot(inDir, shadingPt) + shadingPt;\n	float lowestToCloud = sqrt(radiusCloud * radiusCloud - dot(lowestPos, lowestPos));\n	return inDir * -lowestToCloud + lowestPos;\n}\n';
	static readonly color_tl: string = '// ref: http://filmicgames.com/archives/75\nvec3 CalcToneMapUncharted2(vec3 hdrColor) {\n	float A = 0.22;  // shoulder strength\n	float B = 0.30;  // linear strength\n	float C = 0.10;  // linear angle\n	float D = 0.20;  // toe strength\n	float E = 0.02;  // toe numerator\n	float F = 0.30;  // toe denominator\n	return ((hdrColor * (A * hdrColor + C * B) + D * E) / (hdrColor * (A * hdrColor + B) + D * F)) - E / F;\n}\nvec3 ConvertLinearToSRGB(vec3 linearColor) {\n	return pow(linearColor, vec3(0.4545));\n}\nfloat GetGrain(vec2 co) {\n	float f = sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453;\n	return fract(f);\n}\nvec2 PackToRGB_888(float val) {\n	val = clamp(val, -2.0, 2.0) * 0.25 + 0.5;  // remap [-2, 2] to [0, 1]\n	vec2 result = floor(vec2(val * 255.0, val * 255.0 * 255.0));\n	return fract(result / 255.0);\n}\nfloat UnpackFromRGB_888(vec2 val) {\n	return dot(val, vec2(1.0, 1.0 / 255.0)) * 4.0 - 2.0;  // remap [0, 1] to [-2, 2]\n}\nvec3 PackIntegralPartToRGB_888(float val) {\n	float intPart = floor(val);\n	vec3 result = vec3(0.0);\n	result.r = mod(intPart, 256.0);\n	intPart = floor(intPart / 256.0);\n	result.g = mod(intPart, 256.0);\n	intPart = floor(intPart / 256.0);\n	result.b = mod(intPart, 256.0);\n	return result / 255.0;  // remap [0, 255] to [0, 1]\n}\nfloat CalcLuminance(vec3 color) {\n	return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n';
	static readonly downscaler_fs: string = '// required macros:\n//   - SCALER\nuniform sampler2D	t_srcImg;\nuniform vec2	u_invSrcImgSize;\nvec3 SampleSrcImg(vec2 samplePos) {\n	return texture2D(t_srcImg, samplePos).rgb;\n}\nvoid main(void) {\n	vec2 sampleStartPos = gl_FragCoord.xy * u_invSrcImgSize * SCALER;\n	vec3 summedColor = vec3(0.0);\n	for (float i = 0.0; i < SCALER; ++i) {\n		for (float j = 0.0; j < SCALER; ++j)\n			summedColor += SampleSrcImg(sampleStartPos + vec2(u_invSrcImgSize.x * i, u_invSrcImgSize.y * j));\n	}\n	summedColor *= (1.0 / SCALER / SCALER);\n	gl_FragColor.rgb = max(summedColor, 0.0);\n	gl_FragColor.a = 1.0;\n}\n';
	static readonly earth_fs_part: string = '// dependencies:\n//   - planet_fs_part.glsl\nuniform float	u_heightOcean;\nuniform vec3	u_colorLand;\nuniform vec3	u_colorMountain;\nuniform vec3	u_colorOcean;\nfloat CalcTemperature(vec3 surfacePos, float altitude) {\n	float latitude = degrees(asin(surfacePos.y));\n	float latitudeTerm = (max(abs(latitude), 20.0) - 20.0) * 0.78;\n	float altitudeTerm = max(altitude, 0.0) * 6.49 * 10.0;  // -6.49 K/km\n	return 30.0 - latitudeTerm - altitudeTerm;\n}\nSurfaceProperties CalcSurfaceProperties(SurfaceParam param) {\n	const vec3 COLOR_SNOW = vec3(0.75);  // REF: \"Albedo\". https://en.wikipedia.org/wiki/Albedo\n	SurfaceProperties result;\n	float height = param.fbm;\n	float temperatureJitter = param.fbmAlt * 10.0;\n	float temperature = CalcTemperature(param.surfacePos, smoothstep(u_heightOcean, 1.0, height)) + temperatureJitter;  // re-scale height with smoothstep()\n	float bumpScaler = 5.6e-3;  // default value\n	if (temperature <= 0.0) {\n		result.albedo = COLOR_SNOW;\n		result.glossiness = 0.1;\n		result.specularColor = vec3(0.01801);  // water ice\n		bumpScaler = (height > u_heightOcean ? 3.6e-3 : 1e-5);\n	}\n	else if (height > u_heightOcean) {\n		result.albedo = mix(u_colorMountain, u_colorLand, clamp(temperature / 20.0, 0.0, 1.0));\n		result.glossiness = 0.0;\n		bumpScaler *= max(height - u_heightOcean, 0.6);  // flatten normal based on altitude\n	}\n	else {\n		result.albedo = u_colorOcean;\n		result.glossiness = 0.5;\n		result.specularColor = vec3(0.02732);  // liquid water\n		bumpScaler = 1e-5;\n	}\n	result.normal = CalcBumpNormal(param.surfacePos, height, bumpScaler);\n	result.height = height;\n	return result;\n}\n';
	static readonly fbm_fs: string = '// required macros:\n//   - FBM_GEN_TYPE:	usage for the output texture\n#define TYPE_BASIC_N_TERRAIN	1\n#define TYPE_CLOUDANIM			2\n#define TYPE_MILKYWAY			3\n#ifndef FBM_GEN_TYPE\n	#define FBM_GEN_TYPE	TYPE_BASIC_N_TERRAIN  // default type\n#endif\nuniform sampler2D	t_gradients;\nuniform samplerCube	t_prevFbm;\nuniform bool		u_usePrevFbm;\nuniform vec4		u_currGridCell;\nuniform vec3		u_displace1;\nuniform vec3		u_displace2;\nuniform float		u_freqScaler;\nvarying vec3		v_modelPosition;\nfloat NoiseWeight(float t) {\n	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);  // 6*t^5 - 15*t^4 + 10*t^3\n}\nvec3 SamplePrecomputedGradient(float x, float y, float z) {\n	float fx = mod(x, 256.0);\n	float fy = mod(y, 256.0);\n	float blockX = mod(z, 16.0) * 256.0;\n	float blockY = floor(z / 16.0) * 256.0;\n	vec2 index = vec2(blockX + fx, blockY + fy) + 0.5;\n	return (texture2D(t_gradients, index / 4096.0).rgb * 16.0 - 1.0);\n}\nfloat Gradient(vec3 index, vec3 delta) {\n	vec3 grad = SamplePrecomputedGradient(index.x, index.y, index.z);\n	return dot(grad, delta);\n}\nfloat PerlinNoise(vec3 p) {\n	// compute noise cell coordinates and offsets\n	vec3 delta = fract(p);\n	vec3 index = mod(floor(p), 256.0);\n	float w000 = Gradient(index, delta);\n	float w100 = Gradient(index + vec3(1.0, 0.0, 0.0), delta - vec3(1.0, 0.0, 0.0));\n	float w010 = Gradient(index + vec3(0.0, 1.0, 0.0), delta - vec3(0.0, 1.0, 0.0));\n	float w110 = Gradient(index + vec3(1.0, 1.0, 0.0), delta - vec3(1.0, 1.0, 0.0));\n	float w001 = Gradient(index + vec3(0.0, 0.0, 1.0), delta - vec3(0.0, 0.0, 1.0));\n	float w101 = Gradient(index + vec3(1.0, 0.0, 1.0), delta - vec3(1.0, 0.0, 1.0));\n	float w011 = Gradient(index + vec3(0.0, 1.0, 1.0), delta - vec3(0.0, 1.0, 1.0));\n	float w111 = Gradient(index + vec3(1.0, 1.0, 1.0), delta - vec3(1.0, 1.0, 1.0));\n	// compute trilinear interpolation of weights\n	float wx = NoiseWeight(delta.x);\n	float wy = NoiseWeight(delta.y);\n	float wz = NoiseWeight(delta.z);\n	float x00 = mix(w000, w100, wx);\n	float x10 = mix(w010, w110, wx);\n	float x01 = mix(w001, w101, wx);\n	float x11 = mix(w011, w111, wx);\n	float y0 = mix(x00, x10, wy);\n	float y1 = mix(x01, x11, wy);\n	return mix(y0, y1, wz);\n}\nstruct Noise8 {\n	vec4 high;\n	vec4 low;\n};\nNoise8 CalcPerlinNoises(vec3 v3Point, float freq) {\n	Noise8 result;\n	result.low.x = PerlinNoise(v3Point);\n	result.low.y = PerlinNoise(v3Point * freq);\n	float currFreq = freq * freq;\n	result.low.z = PerlinNoise(v3Point * currFreq);\n	currFreq *= freq;\n	result.low.w = PerlinNoise(v3Point * currFreq);\n	currFreq *= freq;\n	result.high.x = PerlinNoise(v3Point * currFreq);\n	currFreq *= freq;\n	result.high.y = PerlinNoise(v3Point * currFreq);\n	currFreq *= freq;\n	result.high.z = PerlinNoise(v3Point * currFreq);\n	currFreq *= freq;\n	result.high.w = PerlinNoise(v3Point * currFreq);\n	return result;\n}\nfloat fBmTerrain(Noise8 noise, float lacunarity) {\n	const float offset = 0.05;\n	const float heightScaler = 0.7;\n	float result = (noise.low.x + offset);\n	float freq = lacunarity;\n#define ITERATE(_noise) {  float increment = result * pow(freq, -0.57) * (_noise + offset);  result += increment;  freq *= lacunarity;  }\n	ITERATE(noise.low.y);\n	ITERATE(noise.low.z);\n	ITERATE(noise.low.w);\n	ITERATE(noise.high.x);\n	ITERATE(noise.high.y);\n	ITERATE(noise.high.z);\n	ITERATE(noise.high.w);\n#undef ITERATE\n	return result * heightScaler;\n}\nfloat fBmBasic(Noise8 noise) {\n	const vec4 multiplierLow = vec4(1.0, 0.5, 0.25, 0.125);\n	const vec4 multiplierHigh = vec4(0.0625, 0.03125, 0.015625, 0.0078125);\n	return dot(noise.low, multiplierLow) + dot(noise.high, multiplierHigh);\n}\nfloat fBmMilkyWay(Noise8 noise) {\n	const vec4 multiplierLow = vec4(1.0, 0.5, 0.25, 0.125);\n	const vec4 multiplierHigh = vec4(0.0625, 0.03125, 0.015625, 0.0078125);\n	// multiplying a scaler to $normal (in this case, u_freqScaler) yields better results\n	vec3 normal = normalize(v_modelPosition) * u_freqScaler;\n	float weight = max(1.0 - abs(normal.y), 0.0);\n	vec4 weightHigh;  // => weight(^4, ^3, ^2, ^1)\n	weightHigh.w = weight;\n	weightHigh.z = weight * weight;\n	weightHigh.xy = weightHigh.zw * weightHigh.z;\n	vec4 weightLow = weightHigh * weightHigh.x;  // => weight(^8, ^7, ^6, ^5)\n	return dot(abs(noise.low) * multiplierLow, weightLow)  // only take abs() of the low-freq part\n		+ dot(noise.high * multiplierHigh, weightHigh);\n}\nvoid main(void) {\n	if (gl_FragCoord.x < u_currGridCell.x || gl_FragCoord.x >= u_currGridCell.y)\n		discard;\n	if (gl_FragCoord.y < u_currGridCell.z || gl_FragCoord.y >= u_currGridCell.w)\n		discard;\n	vec3 normal = normalize(v_modelPosition) * u_freqScaler;\n#if FBM_GEN_TYPE == TYPE_BASIC_N_TERRAIN\n	gl_FragColor.rg = PackToRGB_888( fBmBasic( CalcPerlinNoises(normal + u_displace1, 2.0) ) );\n	gl_FragColor.ba = PackToRGB_888( fBmTerrain( CalcPerlinNoises(normal + u_displace2, 2.5), 2.5 ) );\n#elif FBM_GEN_TYPE == TYPE_CLOUDANIM\n	vec3 normalStretched = vec3(normal.x, normal.y * 1.25, normal.z);\n	if (u_usePrevFbm)\n		gl_FragColor.rg = textureCube(t_prevFbm, normal).ba;\n	else\n		gl_FragColor.rg = PackToRGB_888( fBmBasic( CalcPerlinNoises(normalStretched + u_displace1, 3.0) ) );\n	gl_FragColor.ba = PackToRGB_888( fBmBasic( CalcPerlinNoises(normalStretched + u_displace2, 3.0) ) );\n#elif FBM_GEN_TYPE == TYPE_MILKYWAY\n	gl_FragColor.rg = PackToRGB_888( fBmMilkyWay( CalcPerlinNoises(normal + u_displace1, 2.0) ) );\n#else\n	#error FBM_GEN_TYPE is invalid\n#endif  // FBM_GEN_TYPE\n}\n';
	static readonly fbm_vs: string = 'varying vec3	v_modelPosition;\nvoid main(void) {\n	v_modelPosition = position;\n	gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n';
	static readonly gaussianblur_fs: string = '#if defined(DIRECTION) && DIRECTION == 1\n	// vertical\n	#define SAMPLE_POS_ELEM(var)	(var.y)\n#else\n	// horizontal by default\n	#define SAMPLE_POS_ELEM(var)	(var.x)\n#endif\nuniform sampler2D	t_srcImg;\nuniform vec2	u_invSrcImgSize;  // src and dst should have the same size\nvec3 SampleSrcImg(vec2 samplePos) {\n	return texture2D(t_srcImg, samplePos).rgb;\n}\nvoid main(void) {\n	const float halfKernel = 7.0;\n	const float sigma = 0.6;\n	vec3 summedColor = vec3(0.0);\n	float summedWeight = 0.0;\n	vec2 samplePos = gl_FragCoord.xy;\n	SAMPLE_POS_ELEM(samplePos) -= halfKernel;\n	samplePos *= u_invSrcImgSize;\n	for (float i = -halfKernel; i <= halfKernel; ++i) {\n		if (SAMPLE_POS_ELEM(samplePos) >= 0.0 && SAMPLE_POS_ELEM(samplePos) <= 1.0) {\n			float weight = exp(-i*i / 2.0*sigma*sigma) / (2.0*3.1415926*sigma*sigma);\n			summedWeight += weight;\n			summedColor += weight * SampleSrcImg(samplePos);\n		}\n		SAMPLE_POS_ELEM(samplePos) += SAMPLE_POS_ELEM(u_invSrcImgSize);\n	}\n	if (summedWeight > 0.0)\n		gl_FragColor.rgb = summedColor / summedWeight;\n	gl_FragColor.a = 1.0;\n}\n';
	static readonly histogram_fs: string = 'void main(void) {\n	gl_FragColor = vec4(1.0);\n}\n';
	static readonly histogram_vs_part: string = '// required macros:\n//   - BUCKET_SIZE\n//   - OUTPUT_SIZE\nuniform sampler2D	t_color;\nuniform vec2	u_invImgSize;  // of source image\nvoid main(void) {\n	// to sample with a window of size defined in ImgProc.Histogram.sampleWindowSize\n	vec2 samplePos = position.xy * u_invImgSize + 0.5;\n	if (samplePos.x < 0.0 || samplePos.x > 1.0 || samplePos.y < 0.0 || samplePos.y > 1.0) {\n		gl_Position = vec4(10.0);\n		return;\n	}\n	else {\n	float luminance = CalcLuminance(texture2D(t_color, samplePos).rgb);\n	// TODO: replace hard-coded numbers like 128.0 with macros\n	// clamp to [-128, 128) and remap to [0, 256) with each bucket 2^(1/BUCKET_SIZE) wide\n	float bucketIdx = clamp(log2(luminance) * BUCKET_SIZE, -128.0, 127.0) + 128.0;\n	// 1) $outPos divided by 8, to range [0, 2);\n	// 2) then add an offset of half pixel\n	vec2 outPos = vec2(mod(bucketIdx, OUTPUT_SIZE), floor(bucketIdx / OUTPUT_SIZE)) * (2.0/OUTPUT_SIZE) + (0.5/OUTPUT_SIZE);\n	gl_Position = vec4(outPos - 1.0, 1.0, 1.0);\n	gl_PointSize = 1.0;\n	}\n}\n';
	static readonly milkyway_fs: string = 'uniform samplerCube	t_noise;\nuniform mat4	u_inverseProjView;\nuniform vec3	u_galacticCamPos;  // affected by the angle between galatic and ecliptic planes\nuniform float	u_distToGalacticCenter;\nuniform float	u_rhoZero;\nuniform float	u_densityGas;\nvarying vec3	v_modelPosition;\nfloat IntegrateStarDensity(vec3 dir) {\n	// REF: https://en.wikipedia.org/wiki/Thin_disk\n	// REF: https://en.wikipedia.org/wiki/Milky_Way\n	const float sampleLen = 1.0;  // unit: kpc\n	const int sampleNum = 30;  // sampleLen*sampleNum >= 30kpc ~estimated Milky Way diameter\n	vec3 centerPos = vec3(u_distToGalacticCenter, 0.0, 0.0);  // distance from galactic center to sun ~8kpc\n	float totalDensity = 0.0;\n	float currentStep = 0.0;\n	for (int i = 0; i < sampleNum; ++i) {\n		float distToSun = sampleLen * 0.5 + currentStep;\n		vec3 samplePos = dir * distToSun;\n		float distToCenVert = abs(samplePos.y - centerPos.y);\n		float distToCenHori = distance(samplePos.xz, centerPos.xz);\n		totalDensity += (\n			  exp(distToCenHori / -3.5 + distToCenVert / -0.4)  // Thin Disk: scale length ~3.5kpc, scale height ~0.4kpc\n			+ exp(length(samplePos - centerPos) / -0.6)  // Bulge: scale radius ~0.6kpc\n		);\n		currentStep += sampleLen;\n	}\n	return totalDensity;\n}\n// inter-stellar gas\nfloat FetchGasDensity(vec3 dir) {\n	vec4 fbm = textureCube(t_noise, dir);\n	return UnpackFromRGB_888(fbm.rg);\n}\nvec3 CompositeMilkyWay(float densityStars, float grain, float densityGas) {\n	const vec3 colorStar = vec3(1.0, 0.9, 0.7);\n	const vec3 colorGas = vec3(0.12, 0.06, 0.02);\n	const vec3 extinction = vec3(8e-1, 13.5e-1, 23e-1);  // non-physically based extinction coefficient\n	float densityGalaxy = densityStars * grain - 2.5e-2;  // substract a little bit (2.5e-2) to counter some overestimate\n	vec3 transmittance = exp(-extinction * densityGas * u_densityGas);  // Beer-Lambert law for transmittance due to gases\n	return colorStar * transmittance * densityGalaxy;\n}\nvoid main() {\n	vec4 reprojected = u_inverseProjView * vec4(v_modelPosition, 1.0);\n	reprojected /= reprojected.w;\n	vec3 dir = normalize(reprojected.xyz - u_galacticCamPos);\n	// add grains to provide a more plausible appearance\n	vec2 sphericalCoord = vec2(acos(dir.z), atan(dir.y/dir.x));\n	sphericalCoord = floor(sphericalCoord * 1e3) * 1e-3;  // drop digits smaller than 1e-3 to avoid flickering\n	float grain = GetGrain(sphericalCoord) * 0.5 + 1.0;  // remap to [1.0, 1.5]\n	gl_FragColor.rgb = CompositeMilkyWay(IntegrateStarDensity(dir), grain, FetchGasDensity(dir)) * u_rhoZero;\n}\n';
	static readonly normal_tl: string = 'uniform mat4	modelMatrix;\nvec3 CalcBumpNormal(vec3 modelNPos, float fbm, float scaler) {\n	vec3 dPos_dX = dFdx(modelNPos);\n	vec3 dPos_dY = dFdy(modelNPos);\n	mat3 tan2obj = mat3(normalize(dPos_dX), normalize(dPos_dY), modelNPos);\n	float tan_bumpNormal_x = -dFdx(fbm) / length(dPos_dX) * scaler;\n	float tan_bumpNormal_y = -dFdy(fbm) / length(dPos_dY) * scaler;\n	vec3 tan_bumpNormal = vec3(tan_bumpNormal_x, tan_bumpNormal_y, sqrt(1.0-tan_bumpNormal_x*tan_bumpNormal_x+tan_bumpNormal_y*tan_bumpNormal_y));\n	vec4 bumpNormal = modelMatrix * vec4(tan2obj * normalize(tan_bumpNormal), 0.0);\n	return normalize(bumpNormal.xyz);\n}\n';
	static readonly planet_fs_part: string = '// dependencies:\n//   - brdf_tl.glsl\n//   - cloud_tl.glsl\n//   - color_tl.glsl\n//   - normal_tl.glsl\n//   - scattering_tl.glsl\nuniform samplerCube	t_noise;\nuniform vec3	u_lightColor;\nuniform float	u_radius;\nuniform mat4	u_invModelMat;\nvarying vec3	v_modelPosition;	// model-space position\nvarying vec3	v_worldNormal;		// world-space normal (normalized)\nvoid main(void) {\n	// constants\n	vec3 modelNPos = normalize(v_modelPosition);  // normalized model-space position\n	vec3 worldNormal = normalize(v_worldNormal);\n	// prepare for surface\n	SurfaceParam surfParam;\n	{\n		vec4 packedFBM = textureCube(t_noise, modelNPos);\n		surfParam.surfacePos = modelNPos;\n		surfParam.dotSunLight = dot(worldNormal, -u_lightDir);\n		surfParam.fbm = UnpackFromRGB_888(packedFBM.ba);\n		surfParam.fbmAlt = UnpackFromRGB_888(packedFBM.rg);\n	}\n	SurfaceProperties surface = CalcSurfaceProperties(surfParam);\n	// TODO: sample in-scattering along zenith as ambient light\n/*\n	InScatteringParam inSctrParam;\n	inSctrParam.viewPos = v_worldPosition * (u_planetRadius / u_radius);\n	inSctrParam.viewDir = surface.normal;\n	inSctrParam.lightDir = u_lightDir;\n	vec3 inScattering = IntegrateInScattering(inSctrParam);\n*/\n	// shadows casted by clouds\n	vec3 cloudSampleWorldSpace = GetCloudSamplePosition(v_worldPosition / u_radius * u_planetRadius, u_lightDir, u_planetRadius);\n	vec3 cloudSampleModelSpace = (u_invModelMat * vec4(normalize(cloudSampleWorldSpace), 0.0)).xyz;\n	float cloudThickness = EvalCloudThickness(SampleCloud(cloudSampleModelSpace));\n	float cloudShadow = EvalCloudTransmittance(EvalCloudOpticalDepth(cloudThickness));\n	vec3 trmtFromSun = SampleTransmittance(surfParam.dotSunLight, surface.height * 1e4);\n	vec3 radiance = CalcLighting(surface, u_lightDir) * u_lightColor * trmtFromSun * cloudShadow;\n	gl_FragColor = vec4(radiance, 1.0);\n}\n';
	static readonly planet_vs: string = '// required macros:\n//   - MESH_TYPE:	type of the mesh\n#define TYPE_SURFACE	0\n#define TYPE_ATMOSPHERE	1\n#define TYPE_CLOUD		2\n#ifndef MESH_TYPE\n	#define MESH_TYPE	TYPE_SURFACE\n#endif\nuniform float	u_radius;\nuniform float	u_radiusAtmo;\nuniform float	u_radiusCloud;\nvarying vec3	v_modelPosition;	// model-space position\nvarying vec3	v_worldPosition;	// world-space position (normalized)\nvarying vec3	v_worldNormal;		// world-space normal (normalized)\nvoid main(void) {\n#if MESH_TYPE == TYPE_SURFACE\n	float radius = u_radius;\n#elif MESH_TYPE == TYPE_ATMOSPHERE\n	float radius = u_radiusAtmo;\n#elif MESH_TYPE == TYPE_CLOUD\n	float radius = u_radiusCloud;\n#else\n	#error MESH_TYPE isinvalid\n#endif  // MESH_TYPE\n	gl_Position = modelMatrix * vec4(position * radius, 1.0);\n	v_worldPosition = gl_Position.xyz / gl_Position.w;\n	v_modelPosition = position * radius;\n	v_worldNormal = normalize(modelMatrix * vec4(normal, 0.0)).xyz;\n	gl_Position = projectionMatrix * viewMatrix * gl_Position;\n}\n';
	static readonly posteffect_fs_part: string = '#define ToneMapping	ReinhardToneMapping\n//#define ToneMapping	CalcToneMapUncharted2\nuniform sampler2D	t_color;\nuniform vec2	u_random;\nuniform vec2	u_invImgSize;\nuniform float	u_exposure;\nvoid main(void) {\n	vec2 samplePos = gl_FragCoord.xy * u_invImgSize;\n	vec3 hdrColor = max(texture2D(t_color, samplePos).rgb, 0.0) * u_exposure;\n	vec3 ldrLinearColor = ToneMapping(hdrColor);\n	gl_FragColor.rgb = ConvertLinearToSRGB(ldrLinearColor);\n	gl_FragColor.rgb += (GetGrain(gl_FragCoord.xy + u_random) - 0.5) / 256.0;  // anti-banding\n	gl_FragColor.a = 1.0;\n}\n';
	static readonly posteffect_vs: string = 'void main(void) {\n	gl_Position = vec4(position, 1.0);\n}\n';
	static readonly scattering_tl: string = '// optional macros:\n//   - LOOK_UP_SAMPLE_TRSM:		while integrating in-scattering, commit a texture\n//								lookup for sample\'s transmittance to eye; otherwise\n//								an interpolation is used as approximation\nuniform sampler2D 	t_opticalDepth;\nuniform vec3	u_optDepTexCoeff;  // let N = size(t_transmittance), u_trsmTexCoeff = vec3((N-1)/N/maxAngle, (N-1)/N/atmoThickness, 0.5/N)\nuniform float	u_planetRadius;\nuniform float	u_atmoThickness;\nstruct IntersectParam {\n	vec3 viewPos;\n	vec3 viewDir;\n	float radius;\n};\nstruct InScatteringParam {\n	vec3 viewPos;\n	vec3 viewDir;  // from viewPos\n	vec3 lightDir;\n};\nstruct IntersectResult {\n	float distToNearInter;  // distance to the nearer intersection\n	float distToFarInter;  // distance to the farther intersection\n};\nstruct PlanetIntersectResult {\n	bool hitsGround;\n	IntersectResult t;\n};\n// remap to transmittance table x-coordinate\nfloat RemapToTrsmTblX(float cosChi) {\n	return acos(clamp(cosChi, -1.0, 1.0)) * u_optDepTexCoeff.x;  // * (N-1) / N / maxAngle\n}\n// remap to transmittance table y-coordinate\nfloat RemapToTrsmTblY(float heightInMeter) {\n	return heightInMeter * u_optDepTexCoeff.y;  // * (N-1) / N / atmoThickness\n}\nvec3 SampleTransmittance(float cosChi, float height) {\n	vec3 opticalDepth = texture2D(\n		t_opticalDepth,\n		vec2(RemapToTrsmTblX(cosChi), RemapToTrsmTblY(height)) + u_optDepTexCoeff.z  // offset towards the texel center\n	).rgb;\n	return exp(opticalDepth);  // assuming all texels are 0 or negative\n}\n// sphere is assume to be at the origin\nIntersectResult IntersectSphere(IntersectParam param) {\n	IntersectResult result;\n	float distToNearest = dot(-param.viewPos, param.viewDir);  // view ray\'s nearest point to origin\n	// temp variables\n	float distMin = length(param.viewPos + distToNearest * param.viewDir);  // distance to center from the nearest point\n	float distHalfIntersection = sqrt(max(param.radius * param.radius - distMin * distMin, 0.0));\n	result.distToNearInter = distToNearest - distHalfIntersection;\n	result.distToFarInter = distToNearest + distHalfIntersection;\n	return result;\n}\n// cylinder is assumed to aligned with z-axis\nIntersectResult IntersectShadowCylinder(IntersectParam param) {\n	IntersectParam newParam;\n	newParam.viewDir = vec3(normalize(param.viewDir.xy), 0.0);\n	newParam.viewPos = vec3(param.viewPos.xy, 0.0);\n	newParam.radius = u_planetRadius;\n	IntersectResult result = IntersectSphere(newParam);\n	float scaler = length(param.viewDir) / length(param.viewDir.xy);\n	result.distToNearInter *= scaler;\n	result.distToFarInter *= scaler;\n	return result;\n}\n// similar to IntersectSphere() but with consideration of atmosphere\n// TODO: to support intersection from view positions within atmosphere\nPlanetIntersectResult IntersectPlanet(InScatteringParam param) {\n	PlanetIntersectResult result;\n	float distToNearest = -dot(param.viewPos, param.viewDir);  // view ray\'s nearest point to origin, namely the lowest point\n	// temp variables\n	float distLowest = length(param.viewPos + distToNearest * param.viewDir);  // distance to planet center from the lowest point\n	float distLowestSq = distLowest * distLowest;\n	float radiusAtm = u_planetRadius + u_atmoThickness;\n	float distLowestToGroundSq = u_planetRadius * u_planetRadius - distLowestSq;\n	float distLowestToAtmSq = radiusAtm * radiusAtm - distLowestSq;\n	result.hitsGround = (distLowestToGroundSq >= 0.0);\n	result.t.distToFarInter = (result.hitsGround ? distToNearest - sqrt(distLowestToGroundSq) : distToNearest + sqrt(distLowestToAtmSq));\n	result.t.distToNearInter = max(distToNearest - sqrt(distLowestToAtmSq), 0.0);\n	return result;\n}\nbool IsShadowed(vec3 pos, vec3 lightDir, float radius) {\n	float dotLV = dot(pos, -lightDir);\n	vec3 closestPt = lightDir * dotLV + pos;\n	return !(dotLV >= 0.0 || length(closestPt) > radius - 10.0);\n}\n// should only be used when view ray hits ground in the shadowed hemisphere.\nvoid RefineWithShadowCylinder(InScatteringParam param, inout PlanetIntersectResult result) {\n	// TODO: rotate everything if the light direction is not exactly towards the negative z-axis\n	IntersectParam itrsctParam;\n	itrsctParam.viewPos = param.viewPos;\n	itrsctParam.viewDir = param.viewDir;\n	itrsctParam.radius = u_planetRadius;\n	IntersectResult itrsctCylinder = IntersectShadowCylinder(itrsctParam);\n	if (length(param.viewPos.xy) > u_planetRadius)\n		result.t.distToFarInter = max(itrsctCylinder.distToNearInter, result.t.distToNearInter);\n	else\n		result.t.distToNearInter = min(itrsctCylinder.distToFarInter, result.t.distToFarInter);\n}\nvec3 GetPlanetaryTransmittance(InScatteringParam param) {\n	PlanetIntersectResult intsct = IntersectPlanet(param);\n	vec3 posSample = param.viewDir * intsct.t.distToFarInter + param.viewPos;\n	float distSampleToOrigin = length(posSample);\n	return SampleTransmittance(-dot(param.viewDir, posSample / distSampleToOrigin), distSampleToOrigin - u_planetRadius);\n}\n// TODO: to support integration outwards from position within atmosphere\nvec3 IntegrateInScattering(InScatteringParam param, PlanetIntersectResult intsct) {\n	vec3 result = vec3(0.0);\n	// start/end position may need some refinement\n	if (IsShadowed(param.viewDir * intsct.t.distToFarInter + param.viewPos, param.lightDir, u_planetRadius))\n		RefineWithShadowCylinder(param, intsct);\n	// ray-marching setup\n	const int NUM_SAMPLE_MAX = 20;\n	const int NUM_SAMPLE_MIN = 8;\n	float segmentCount = (intsct.hitsGround ? float(NUM_SAMPLE_MIN) : float(NUM_SAMPLE_MAX));\n	float segmentLength = (intsct.t.distToFarInter - intsct.t.distToNearInter) / segmentCount;  // should always be positive\n	// initialize with the far endpoint of the 1st segment\n	vec3 posFarEndPoint = param.viewDir * intsct.t.distToFarInter + param.viewPos;  // the far endpoint of each segment\n	float distFarEndPointToOrigin = length(posFarEndPoint);  // not actually needed in the iteration\n	vec3 trsmFarEndPoint = SampleTransmittance(\n		-dot(param.viewDir, posFarEndPoint / distFarEndPointToOrigin),\n		distFarEndPointToOrigin - u_planetRadius\n	);\n	// integral with ray-marching\n	for (int i = 0; i < NUM_SAMPLE_MAX; ++i) {\n		if (float(i) >= segmentCount)\n			break;\n		vec3 posSample = segmentLength * -0.5 * param.viewDir + posFarEndPoint;  // sample at the center of the segment\n		vec3 trsmSunToSample = vec3(0.0);\n		vec3 trsmSampleToEye = vec3(0.0);\n		// light that scatters in\n		{\n			float distSampleToOrigin = length(posSample);\n			vec3 posSampleNorm = posSample / distSampleToOrigin;  // counting on compiler to reuse registers\n			float sampleHeight = distSampleToOrigin - u_planetRadius;\n			trsmSunToSample = SampleTransmittance(-dot(param.lightDir, posSampleNorm), sampleHeight);\n#if defined(LOOK_UP_SAMPLE_TRSM)\n			trsmSampleToEye = SampleTransmittance(-dot(param.viewDir, posSampleNorm), sampleHeight);\n#endif  // LOOK_UP_SAMPLE_TRSM\n		}\n		// update shared variables\n		{\n			posFarEndPoint -= param.viewDir * segmentLength;\n			float distFarEndPointToOrigin = length(posFarEndPoint);  // counting on compiler to reuse registers\n			vec3 trsmNearEndPoint = SampleTransmittance(\n				-dot(param.viewDir, posFarEndPoint / distFarEndPointToOrigin),\n				distFarEndPointToOrigin - u_planetRadius\n			);\n			// 1. adding 1e-10 to avoid 0 being divided by 0\n			// 2. because transmittance texture is somehow too coarse if intsct.hitsGround = false,\n			//    to avoid artifacts must we handle situations of trsmFarEndPoint > trsmNearEndPoint\n			vec3 trsmDelta = min(trsmFarEndPoint / (trsmNearEndPoint + 1e-10), 1.0);\n	#if !defined(LOOK_UP_SAMPLE_TRSM)\n			trsmSampleToEye = sqrt(trsmFarEndPoint * trsmNearEndPoint);  // approximate the transmittance from posSample to eye\n	#endif  // !LOOK_UP_SAMPLE_TRSM\n			trsmFarEndPoint = trsmNearEndPoint;\n			result += trsmSunToSample * trsmSampleToEye * -log(trsmDelta);  // -log(trsmDelta) = beta*∫dt = optical depth\n		}\n	}\n	float phaseCosTheta = dot(-param.viewDir, param.lightDir);\n	float phase = (3.0 / 16.0 / 3.1415926) * (1.0 + phaseCosTheta*phaseCosTheta);\n	return result * phase;\n}\n';
	static readonly simplecolor_fs: string = 'uniform vec4	u_color;\nvoid main(void) {\n	gl_FragColor = u_color;\n}\n';
	static readonly star_vs: string = 'varying vec3	v_color;\nvarying vec3	v_worldPosition;	// world-space position (normalized)\nvoid main(void) {\n#ifdef USE_COLOR\n	v_color = color;\n#endif  // USE_COLOR\n	vec4 worldPos = modelMatrix * vec4(position, 1.0);\n	v_worldPosition = worldPos.xyz / worldPos.w;\n	vec4 transformed = projectionMatrix * viewMatrix * worldPos;\n	transformed.z = transformed.w;  // always inside the frustrum\n	gl_Position = transformed;\n	gl_PointSize = 1.0;\n}\n';
	static readonly sun_fs: string = '// required macros:\n//   - ON_MOBILE\nuniform vec3	u_color;\nuniform float	u_surfaceAngle;  // defines the visual size of the Sun\nuniform vec3	u_viewPos;\nuniform vec3	u_centerPos;  // center of the Sun\nvarying vec3	v_worldPosition;\nfloat EvalCoronaIntensity(float tangent) {\n#if ON_MOBILE\n		// color buffer on mobiles is in half-float format and thus unable to store detailed attenuation\n		const float ATTENUATION_POWER = -8.0;\n#else\n		const float ATTENUATION_POWER = -5.0;\n#endif  // ON_MOBILE\n		float outness = tangent / u_surfaceAngle + 0.4;  // add 0.4 to offset a little, \"pulling\" the corona inwards, to make it dimmer\n		return clamp(pow(outness, ATTENUATION_POWER), 0.0, 1.0);  // use hyperbola as attenuation function\n}\nvoid main(void) {\n	vec3 viewDir = normalize(v_worldPosition - u_viewPos);\n	vec3 centerDir = normalize(u_centerPos - u_viewPos);\n	float cosine = dot(viewDir, centerDir);\n	float tangent = sqrt(1.0 - cosine*cosine) / cosine;\n	if (tangent <= u_surfaceAngle)\n		gl_FragColor.a = 1.0;  // Sun surface\n	else\n		gl_FragColor.a = EvalCoronaIntensity(tangent);  // corona\n	gl_FragColor.rgb = u_color;\n}\n';
	static readonly uintconvert_fs_part: string = 'uniform sampler2D	t_srcImg;\nuniform vec2	u_invSrcImgSize;\nvoid main(void) {\n	vec2 samplePos = gl_FragCoord.xy * u_invSrcImgSize;\n	float val = texture2D(t_srcImg, samplePos).r;  // only red channel\n	gl_FragColor.rgb = PackIntegralPartToRGB_888(val);\n	gl_FragColor.a = 1.0;\n}\n';
	static readonly vertexcolor_fs: string = 'varying vec3	v_color;\nvoid main(void) {\n	gl_FragColor.rgb = v_color;\n	gl_FragColor.a = 1.0;\n}\n';
}