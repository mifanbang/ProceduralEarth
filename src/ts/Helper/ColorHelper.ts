/**
 * ProceduralEarth - WebGL-based renderer to procedurally generate Earths
 * https://debug.tw/proc_earth
 *
 * Copyright (C) 2017 Mifan Bang <https://debug.tw>
 *
 * Licensed under the MIT License.
 */


namespace ColorHelper {



export type Spectrum = Array<number>;


export interface XYZ {
	x: number;
	y: number;
	z: number;
}


export interface RGB {
	r: number;
	g: number;
	b: number;
}



const xyzMatchingFunc: Array<Array<number>> = [
	[0.003769647, 0.0004146161, 0.0184726],  // 390nm
	[0.009382967, 0.001059646, 0.04609784],  // 395
	[0.02214302, 0.002452194, 0.109609],  // 400
	[0.04742986, 0.004971717, 0.2369246],  // 405
	[0.08953803, 0.00907986, 0.4508369],  // 410
	[0.1446214, 0.01429377, 0.7378822],  // 415
	[0.2035729, 0.02027369, 1.051821],  // 420
	[0.2488523, 0.02612106, 1.305008],  // 425
	[0.2918246, 0.03319038, 1.552826],  // 430
	[0.3227087, 0.0415794, 1.74828],  // 435
	[0.3482554, 0.05033657, 1.917479],  // 440
	[0.3418483, 0.05743393, 1.918437],  // 445
	[0.3224637, 0.06472352, 1.848545],  // 450
	[0.2826646, 0.07238339, 1.664439],  // 455
	[0.2485254, 0.08514816, 1.522157],  // 460
	[0.2219781, 0.1060145, 1.42844],  // 465
	[0.1806905, 0.1298957, 1.25061],  // 470
	[0.129192, 0.1535066, 0.9991789],  // 475
	[0.08182895, 0.1788048, 0.7552379],  // 480
	[0.04600865, 0.2064828, 0.5617313],  // 485
	[0.02083981, 0.237916, 0.4099313],  // 490
	[0.007097731, 0.285068, 0.3105939],  // 495
	[0.002461588, 0.3483536, 0.2376753],  // 500
	[0.003649178, 0.4277595, 0.1720018],  // 505
	[0.01556989, 0.5204972, 0.1176796],  // 510
	[0.04315171, 0.6206256, 0.08283548],  // 515
	[0.07962917, 0.718089, 0.05650407],  // 520
	[0.1268468, 0.7946448, 0.03751912],  // 525
	[0.1818026, 0.8575799, 0.02438164],  // 530
	[0.2405015, 0.9071347, 0.01566174],  // 535
	[0.3098117, 0.9544675, 0.00984647],  // 540
	[0.3804244, 0.9814106, 0.006131421],  // 545
	[0.4494206, 0.9890228, 0.003790291],  // 550
	[0.5280233, 0.9994608, 0.002327186],  // 555
	[0.6133784, 0.9967737, 0.001432128],  // 560
	[0.7016774, 0.9902549, 0.0008822531],  // 565
	[0.796775, 0.9732611, 0.0005452416],  // 570
	[0.8853376, 0.9424569, 0.0003386739],  // 575
	[0.9638388, 0.8963613, 0.0002117772],  // 580
	[1.051011, 0.8587203, 0.0001335031],  // 585
	[1.109767, 0.8115868, 0.00008494468],  // 590
	[1.14362, 0.7544785, 0.00005460706],  // 595
	[1.151033, 0.6918553, 0.00003549661],  // 600
	[1.134757, 0.6270066, 0.00002334738],  // 605
	[1.083928, 0.5583746, 0.00001554631],  // 610
	[1.007344, 0.489595, 0.00001048387],  // 615
	[0.9142877, 0.4229897, 0],  // 620
	[0.8135565, 0.3609245, 0],  // 625
	[0.6924717, 0.2980865, 0],  // 630
	[0.575541, 0.2416902, 0],  // 635
	[0.4731224, 0.1943124, 0],  // 640
	[0.3844986, 0.1547397, 0],  // 645
	[0.2997374, 0.119312, 0],  // 650
	[0.2277792, 0.08979594, 0],  // 655
	[0.1707914, 0.06671045, 0],  // 660
	[0.1263808, 0.04899699, 0],  // 665
	[0.09224597, 0.03559982, 0],  // 670
	[0.0663996, 0.02554223, 0],  // 675
	[0.04710606, 0.01807939, 0],  // 680
	[0.03292138, 0.01261573, 0],  // 685
	[0.02262306, 0.008661284, 0],  // 690
	[0.01575417, 0.006027677, 0],  // 695
	[0.01096778, 0.004195941, 0],  // 700
	[0.00760875, 0.002910864, 0],  // 705
	[0.005214608, 0.001995557, 0],  // 710
	[0.003569452, 0.001367022, 0],  // 715
	[0.002464821, 0.0009447269, 0],  // 720
	[0.001703876, 0.000653705, 0],  // 725
	[0.001186238, 0.000455597, 0],  // 730
	[0.0008269535, 0.0003179738, 0],  // 735
	[0.0005758303, 0.0002217445, 0],  // 740
	[0.0004058303, 0.0001565566, 0],  // 745
	[0.0002856577, 0.0001103928, 0],  // 750
	[0.0002021853, 0.00007827442, 0],  // 755
	[0.000143827, 0.00005578862, 0],  // 760
	[0.0001024685, 0.00003981884, 0],  // 765
	[0.00007347551, 0.00002860175, 0],  // 770
	[0.0000525987, 0.00002051259, 0],  // 775
	[0.00003806114, 0.00001487243, 0],  // 780
	[0.00002758222, 0.00001080001, 0],  // 785
	[0.00002004122, 0.00000786392, 0],  // 790
	[0.00001458792, 0.000005736935, 0],  // 795
	[0.00001068141, 0.000004211597, 0],  // 800
	[0.000007857521, 0.000003106561, 0],  // 805
	[0.000005768284, 0.000002286786, 0],  // 810
	[0.000004259166, 0.000001693147, 0],  // 815
	[0.000003167765, 0.000001262556, 0],  // 820
	[0.000002358723, 9.422514e-7, 0],  // 825
	[0.000001762465, 7.05386e-7, 0]  // 830
];



// Planck's law
function EvalSpectralRadiance(temperature: number, wavelength: number) : number {
	let h = 6.626e-34;
	let c = 3e8;
	let k = 1.38e-23;

	return 2 * h * c * c * Math.pow(wavelength, -5)
		/ (Math.exp(h * c / k / (wavelength * temperature)) - 1);
}



export function EvalSpectrum(temperature: number) : Spectrum {
	// unit: nm
	const START = 390;
	const END = 830;
	const STEP = 5;
	const NUM_SAMPLE = Math.round((END - START) / STEP + 1);

	const dLambda = STEP * 1e-9;
	let spectrum = new Array(NUM_SAMPLE);
	for (let i = START; i <= END; i += STEP)
		spectrum[Math.round((i - START) / STEP)] = EvalSpectralRadiance(temperature, i * 1e-9) * dLambda;
	return spectrum;
}



export function EvalXYZ(spectrum: Spectrum) : XYZ {
	if (spectrum.length != xyzMatchingFunc.length)
		throw new Error('#samples mismatched with matching functions');

	let invIntegralY = 1 / xyzMatchingFunc.reduce( (accu, val) => accu + val[1] , 0);
	let numSamples = spectrum.length;
	let [x, y, z] = [0, 0, 0];
	for (let i = 0; i < numSamples; ++i) {
		let sampleSpec = spectrum[i];
		let sampleMatching = xyzMatchingFunc[i];
		x += sampleSpec * sampleMatching[0];
		y += sampleSpec * sampleMatching[1];
		z += sampleSpec * sampleMatching[2];
	}

	return { x: x * invIntegralY, y: y * invIntegralY, z: z * invIntegralY };
}



export function ConvertXYZToRGB(xyz: XYZ) : RGB {
	return {
		r:  3.2404542*xyz.x - 1.5371385*xyz.y - 0.4985314*xyz.z,
		g: -0.9692660*xyz.x + 1.8760108*xyz.y + 0.0415560*xyz.z,
		b:  0.0556434*xyz.x - 0.2040259*xyz.y + 1.0572252*xyz.z
	};
}



export function EvalLuminance(rgb: RGB) : number {
	return 0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b;
}



export function EvalColorAndLumi(temperature: number) : { color: RGB, lumi: number } {
	let spectrum = EvalSpectrum(temperature);
	let xyz = EvalXYZ(spectrum);
	let rgb = ConvertXYZToRGB(xyz);
	let lumi = xyz.y;  // by definition
	rgb.r /= lumi;
	rgb.g /= lumi;
	rgb.b /= lumi;

	return { color: rgb, lumi: lumi };
}



}  // namespace ColorHelper

